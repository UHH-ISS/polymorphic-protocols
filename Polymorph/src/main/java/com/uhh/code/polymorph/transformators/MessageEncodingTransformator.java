package com.uhh.code.polymorph.transformators;

import com.google.protobuf.InvalidProtocolBufferException;
import com.google.protobuf.Method;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.CodeBlock;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.TypeSpec;
import com.uhh.code.polymorph.RandomStringGenerator;
import com.uhh.code.polymorph.StringHelpers;
import com.uhh.code.polymorph.TransformationResult;
import com.uhh.code.polymorph.protobuilder.ProtoMessage;
import com.uhh.code.polymorph.protobuilder.ProtoType;
import com.uhh.code.polymorph.protobuilder.ProtoTypeSizeEstimator;

import javax.crypto.*;
import javax.lang.model.element.Modifier;
import java.io.*;
import java.security.GeneralSecurityException;
import java.security.InvalidKeyException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.Random;

// Transformator for changing the Encoding of 1 Message
class MessageEncodingTransformator {
    private Random rnd;
    private boolean ignoreTransformations;

    private MessageEncodingTransformator()
    {
    }

    public MessageEncodingTransformator(Random rnd)
    {
        this.rnd = rnd;
    }

    public void TransformBuilderToEncrypted(TypeSpec.Builder javaWrapper, MethodSpec.Builder parseInputStream, MethodSpec.Builder parseInputIO, MethodSpec.Builder writeToStream, MethodSpec.Builder toByteArray)
    {

        parseInputStream.beginControlFlow("try")
                .addStatement("var decryptedData = AESDecrypt.doFinal(data.readAllBytes())")
                .addStatement("data = new java.io.ByteArrayInputStream(decryptedData)");

        parseInputIO.beginControlFlow("try")
                .addStatement("data = AESDecrypt.doFinal(data)");

        toByteArray.beginControlFlow("try")
                .addStatement("var encryptedBytes = AESEncrypt.doFinal(wrappedMessage.build().toByteArray())")
                .addStatement("return encryptedBytes");

        writeToStream.addStatement("var encryptedBytes = this.toByteArray()")
                .addStatement("output.write(encryptedBytes)");

        parseInputStream.nextControlFlow("catch ($T e)", GeneralSecurityException.class)
                .addStatement("e.printStackTrace()")
                .endControlFlow();

        parseInputIO.nextControlFlow("catch ($T e)", GeneralSecurityException.class)
                .addStatement("e.printStackTrace()")
                .endControlFlow();

        toByteArray.nextControlFlow("catch ($T e)", GeneralSecurityException.class)
                .addStatement("e.printStackTrace()")
                .endControlFlow()
                .addStatement("return null");
    }

    public TransformationResult PerformTransformation(TypeSpec.Builder javaWrapper, ProtoMessage protoMessage, String protoName)
    {
        String javaPackage = "com.autogenerated.bypolymorph";
        var newClassName = ClassName.get(javaPackage, protoMessage.getName());
        var messageName = protoMessage.getName();
        var wrappedMessageName = protoName + "." + messageName;
        var className =  ClassName.get(javaPackage, wrappedMessageName);

        // method for parsing a message from a inputstream i.e. file i/o
        var wrapperParseFromStream = MethodSpec.methodBuilder("parseFrom")
                .returns(newClassName)
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                .addParameter(InputStream.class, "data")
                .addException(IOException.class);

        // method for parsing messages directly from bytes
        var wrapperParseFromData = MethodSpec.methodBuilder("parseFrom")
                .returns(newClassName)
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                .addException(InvalidProtocolBufferException.class)
                .addException(IOException.class)
                .addParameter(byte[].class, "data");

        // method for writing message to a outputstream
        var wrapperWriteTo = MethodSpec.methodBuilder("writeTo")
                .returns(void.class)
                .addModifiers(Modifier.PUBLIC)
                .addParameter(OutputStream.class, "output")
                .addException(IOException.class)
                .addStatement("setFieldHashes()");

        // method for writing to a byte array
        var wrapperToByteArray = MethodSpec.methodBuilder("toByteArray")
                .returns(byte[].class)
                .addModifiers(Modifier.PUBLIC)
                .addException(IOException.class)
                .addStatement("setFieldHashes()");

        if (!ignoreTransformations)
        {
            protoMessage.setComment("Encrypted using AES");
            TransformBuilderToEncrypted(javaWrapper, wrapperParseFromStream, wrapperParseFromData, wrapperWriteTo, wrapperToByteArray);
        }else{
            wrapperWriteTo.addCode("wrappedMessage.build().writeTo(output);");
            wrapperToByteArray.addCode("return wrappedMessage.build().toByteArray();");
        }

        wrapperParseFromStream
                .addStatement("var parseMsg = $T.parseFrom(data)", className)
                .addStatement("var mergeMsg = $T.newBuilder()", className)
                .addStatement("mergeMsg.mergeFrom((com.google.protobuf.Message)parseMsg)", className)
                .addStatement("var newMsg = new $N()", messageName)
                .addStatement("newMsg.wrappedMessage = mergeMsg")
                .addCode("return newMsg;");

        wrapperParseFromData
                .addStatement("var parseMsg = $T.parseFrom(data)", className)
                .addStatement("var mergeMsg = $T.newBuilder()", className)
                .addStatement("mergeMsg.mergeFrom((com.google.protobuf.Message)parseMsg)", className)
                .addStatement("var newMsg = new $N()", messageName)
                .addStatement("newMsg.wrappedMessage = mergeMsg")
                .addCode("return newMsg;");



        javaWrapper.addMethod(wrapperParseFromStream.build());
        javaWrapper.addMethod(wrapperParseFromData.build());
        javaWrapper.addMethod(wrapperWriteTo.build());
        javaWrapper.addMethod(wrapperToByteArray.build());



        var transformationResult = new TransformationResult(0,0);

        /* TODO: Calculate size overhead */

        transformationResult.size = 0;
        transformationResult.transformationCount = 1;

        return transformationResult;
    }

    public void SetIgnoreTransformations(boolean ignoreTransformations)
    {
        this.ignoreTransformations = ignoreTransformations;
    }
}
